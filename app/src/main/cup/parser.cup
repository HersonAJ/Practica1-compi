package com.example.practica1_compi.analizadores;

import java_cup.runtime.*;
import java.util.*;

parser code {:

    private List<String> syntaxErrors;
    private Lexer lex;

    //conexion del parser y lexer
    public Parser(Lexer lex) {
    super(lex);
    this.lex = lex;
    this.syntaxErrors = new ArrayList<>();
    }

    //getters
    public Lexer getLexer() {
    return this.lex;
    }

    public List<String> getSyntaxErrors() {
    return this.syntaxErrors;
    }

    //metodo que se llamara cuando se encuentre un error
    public void syntax_error(Symbol cur_token) {
        StringBuilder mssBuilder = new StringBuilder();

        //nombre del token encontrado
        mssBuilder.append("Error sintactico: se encontro '");
        mssBuilder.append(symbl_name_from_id(cur_token.sym));

        //valor del token
        if (cur_token.value != null) {
            mssBuilder.append(" (" + cur_token.value.toString() + ")");
        }

        //ubicacion
        mssBuilder.append("' en linea: ");
        mssBuilder.append(cur_token.left);
        mssBuilder.append(", columna: ");
        mssBuilder.append(cur_token.right);

        if (expected_token_ids().isEmpty()) {
            mssBuilder.append(". No se esperaba ningun token adicional");
        } else {
            mssBuilder.append(". se esperaba: ");
            for (Integer expected_token_id : expected_token_ids()) {
                String tokenName = symbl_name_from_id(expected_token_id);

                if (!tokenName.equals("error") &&
                    !tokenName.equals("ERROR") &&
                    !tokenName.equals("ERROR_IDENTIFICADOR_INVALIDO") &&
                    !tokenName.equals("ERROR_DECIMAL_INVALIDO")) {
                        mssBuilder.append(tokenName);
                        mssBuilder.append(" ");
                    }
            }
        }
        syntaxErrors.add(mssBuilder.toString());
    }

        public void report_error(String message, Object info){
            try {
                StringBuilder mssBuilder = new StringBuilder();

                if(info instanceof Symbol){
                    Symbol cur_token = (Symbol) info;
                    mssBuilder.append("Error sintactico: ");

                    //Token que causo el error
                    mssBuilder.append("token '");
                    mssBuilder.append(symbl_name_from_id(cur_token.sym));
                    mssBuilder.append("'");

                    //Lexema si existe
                    if(cur_token.value != null){
                        mssBuilder.append(" con valor '");
                        mssBuilder.append(cur_token.value.toString());
                        mssBuilder.append("'");
                    }

                    //Ubicacion
                    mssBuilder.append(" en linea: ");
                    mssBuilder.append(cur_token.left);
                    mssBuilder.append(", columna: ");
                    mssBuilder.append(cur_token.right);

                    //Mensaje adicional
                    if(message != null && !message.isEmpty()){
                        mssBuilder.append(". ");
                        mssBuilder.append(message);
                    }
                } else {
                    //Si info no es un Symbol solo se usa el mensaje
                    mssBuilder.append("Error sintactico: ");
                    mssBuilder.append(message);
                }

                syntaxErrors.add(mssBuilder.toString().trim());

            } catch (Exception e){
                //Si algo sale mal, todavia se guarda el error
                syntaxErrors.add(("Error sintactico: " + message).trim());
            }
        }

        //Metodo llamado cuando el error no puede ser recuperado

        public void unrecovered_syntax_error(Symbol cur_token){
            StringBuilder mssBuilder = new StringBuilder();
            mssBuilder.append("Error sintactico FATAL - No se puede recuperar del token '");
            mssBuilder.append(symbl_name_from_id(cur_token.sym));
            mssBuilder.append("' en linea: ");
            mssBuilder.append(cur_token.left);
            mssBuilder.append(", columna: ");
            mssBuilder.append(cur_token.right);

            syntaxErrors.add(mssBuilder.toString().trim());
        }

:}

//terminales
terminal SEPARADOR_SECCION;
terminal CONFIG, FIGURA, LETRA, COLOR_HEX;
terminal INICIO, FIN, VAR;
terminal SI, ENTONCES, FINSI;
terminal MIENTRAS, HACER, FINMIENTRAS;
terminal MOSTRAR, LEER;

//operadores
terminal OPERADOR_ASIGNACION;
terminal SUMA, RESTA, MULT, DIV;
terminal MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL, IGUALDAD, DISTINTO;
terminal AND, OR, NOT_LOGICO;
//simbolos
terminal COMA, PIPE, LPAREN, RPAREN;

//literales
terminal NUMERO, CADENA, IDENTIFICADOR;

//errores
terminal ERROR, ERROR_IDENTIFICADOR_INVALIDO, ERROR_DECIMAL_INVALIDO;

//no terminales
non terminal programa;
non terminal seccion_pseudocodigo;
non terminal lista_instrucciones;
non terminal instruccion;

non terminal declaracion;
non terminal asignacion;
non terminal mostrar;
non terminal leer;

non terminal si_condicional;
non terminal mientras_ciclo;

non terminal bloque_simple;
non terminal lista_instrucciones_simples;
non terminal instruccion_simple;

non terminal seccion_configuracion;
non terminal lista_configuraciones;
non terminal configuracion;
non terminal valor_config;

non terminal expresion;
non terminal termino;
non terminal factor;
non terminal condicion;
non terminal COLOR_RGB;

//precedencia
precedence left OR; // para el ||
precedence left AND; //para el &&
precedence right NOT_LOGICO; // para el simbolo de !

precedence left MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL, IGUALDAD, DISTINTO;

precedence left SUMA, RESTA;
precedence left MULT, DIV;


start with programa;

programa ::= seccion_pseudocodigo SEPARADOR_SECCION seccion_configuracion
            ;

//seccion de pseudocodigo
seccion_pseudocodigo ::= INICIO lista_instrucciones FIN
            ;

lista_instrucciones ::= lista_instrucciones instruccion
                    | instruccion
                    ;

instruccion ::= declaracion
            | asignacion
            | mostrar
            | leer
            | si_condicional
            | mientras_ciclo
            ;

//instruccion para no anidar
bloque_simple ::= lista_instrucciones_simples
                ;

lista_instrucciones_simples ::= lista_instrucciones_simples instruccion_simple
                            | instruccion_simple
                            ;

instruccion_simple ::= declaracion
                    | asignacion
                    | mostrar
                    | leer
                    ;

//declaracion y asignacion
declaracion ::= VAR IDENTIFICADOR OPERADOR_ASIGNACION expresion
            | VAR IDENTIFICADOR
            ;

asignacion ::= IDENTIFICADOR OPERADOR_ASIGNACION expresion
            ;

mostrar ::= MOSTRAR CADENA
        | MOSTRAR expresion
        ;

leer ::= LEER IDENTIFICADOR
        ;

//instrucciones de control
si_condicional ::= SI LPAREN condicion RPAREN ENTONCES bloque_simple FINSI
                | SI LPAREN condicion RPAREN ENTONCES bloque_simple FIN SI
                ;

mientras_ciclo ::= MIENTRAS LPAREN condicion RPAREN HACER bloque_simple FINMIENTRAS
                | MIENTRAS LPAREN condicion RPAREN HACER bloque_simple FIN MIENTRAS
                ;


//reglas de configuraciones

seccion_configuracion ::= lista_configuraciones
                        ;

lista_configuraciones ::= lista_configuraciones configuracion
                        | configuracion
                        ;

configuracion ::= CONFIG OPERADOR_ASIGNACION valor_config
                | CONFIG OPERADOR_ASIGNACION valor_config PIPE NUMERO
                ;

valor_config ::= COLOR_HEX
                | COLOR_RGB
                | FIGURA
                | LETRA
                | NUMERO
                ;

//expresiones aritmeticas
expresion ::= expresion SUMA termino
            | expresion RESTA termino
            | termino
            ;

termino ::= termino MULT factor
        | termino DIV factor
        | factor
        ;

factor ::= NUMERO
        |  IDENTIFICADOR
        | LPAREN expresion RPAREN
        ;


//condiciones
condicion ::= expresion MENOR expresion
            | expresion MAYOR expresion
            | expresion MENOR_IGUAL expresion
            | expresion MAYOR_IGUAL expresion
            | expresion IGUALDAD expresion
            | expresion DISTINTO expresion
            | condicion AND condicion
            | condicion OR condicion
            | NOT_LOGICO condicion
            | LPAREN condicion RPAREN
            ;

//condificon para el color rgb
COLOR_RGB ::= expresion COMA expresion COMA expresion
            ;